using System.Reflection;

using Nest;

using Vulns.Core;
using Vulns.Infrastructure;

namespace Vulns.App;

public class VulnerabilitySearchService : SearchService<Vulnerability>
{
    private readonly VulnerabilityRepository _repo;

    public VulnerabilitySearchService(VulnerabilityRepository repo) : base(repo)
    {
        _repo = repo;
    }

    public async Task<SearchResult<Vulnerability>> SearchAsync(VulnerabilitySearchCriteria criteria, CancellationToken token = default)
    {
        var searchQuery = ConstructSearchQuery(criteria);
        return await _repo.SearchAsync(searchQuery, token);
    }

    public VulnerabilitySearchParametersValues GetSearchParametersValuesAsync(CancellationToken token = default)
        => new VulnerabilitySearchParametersValues(
            VulnerabilityAttackVector.List.Select(_ => _.Name).Where(_ => _ != VulnerabilityAttackVector.Unspecified.Name),
            VulnerabilityAttackComplexity.List.Select(_ => _.Name).Where(_ => _ != VulnerabilityAttackComplexity.Unspecified.Name),
            VulnerabilityImpact.List.Select(_ => _.Name).Where(_ => _ != VulnerabilityImpact.Unspecified.Name),
            new string[] { ProductUriType.Hardware.ToString(), ProductUriType.Software.ToString(), ProductUriType.OS.ToString() }
        );

    internal SearchDescriptor<VulnerabilityDocument> ConstructSearchQuery(VulnerabilitySearchCriteria criteria)
    {
        var c = criteria;
        var queryContainer = _repo.CreateQueryContainer();
        _repo.AddDateRangeFilter(v => v.CreatedAt, c.PublishedFrom, c.PublishedTo, queryContainer)
            .AddDateRangeFilter(v => v.ModifiedAt, c.ModifiedFrom, c.ModifiedTo, queryContainer)
            .AddRangeFilter(v => v.Severity!.BaseScore, c.SeverityFrom, c.SeverityTo, queryContainer)
            .AddSingleTermFilter(v => v.HasExploit, c.HasExploit, queryContainer)
            .AddSingleTermFilter(v => v.HasFix, c.HasFix, queryContainer)
            .AddSingleTermFilter(v => v.Severity!.UserInteractionRequired, c.IsUserInteractionRequired, queryContainer)
            .AddMultiTermsFilter(v => v.Issuer!.Id, c.Issuers, queryContainer)
            .AddMultiTermsFilter(v => v.ConfidentialityImpact, c.ConfidentialityImpacts, queryContainer)
            .AddMultiTermsFilter(v => v.IntegrityImpact, c.IntegrityImpacts, queryContainer)
            .AddMultiTermsFilter(v => v.AvailabilityImpact, c.AvailabilityImpacts, queryContainer)
            .AddMultiTermsFilter(v => v.AttackVector, c.AttackVectors, queryContainer)
            .AddMultiTermsFilter(v => v.AttackComplexity, c.AttackComplexities, queryContainer)
            .AddMultiTermsFilter(v => v.Weaknesses, c.Weaknesses, queryContainer);

        if (criteria.VulnerableProducts.Any())
        {
            var productsFilters = _repo.CreateQueryContainer();
            foreach (var productCriteria in criteria.VulnerableProducts)
            {
                var productFilters = _repo.CreateQueryContainer();
                if (!string.IsNullOrEmpty(productCriteria.Vendor))
                    _repo.AddSingleTermFilter(v => v.VulnerableProducts!.First().Vendor, productCriteria.Vendor, productFilters);
                if (!string.IsNullOrEmpty(productCriteria.Product))
                    _repo.AddSingleTermFilter(v => v.VulnerableProducts!.First().Product, productCriteria.Product, productFilters);
                if (!string.IsNullOrEmpty(productCriteria.Version))
                    _repo.AddSingleTermFilter(v => v.VulnerableProducts!.First().Version, productCriteria.Version, productFilters);
                if (!string.IsNullOrEmpty(productCriteria.ProductType))
                    _repo.AddSingleTermFilter(v => v.VulnerableProducts!.First().ProductType, productCriteria.ProductType, productFilters);
                _repo.AddBoolFilters(productFilters, productsFilters);
            }
            var productsNestedFilter = _repo.CreateQueryContainer();
            _repo.AddBoolMinMatch(productsFilters, productsNestedFilter);
            _repo.AddNestedFilter(v => v.VulnerableProducts, queryContainer, productsNestedFilter.ToArray());
        }

        return _repo.ConvertToSearchQuery(c.Phrase, queryContainer, c.Offset, c.Size);
    }
}