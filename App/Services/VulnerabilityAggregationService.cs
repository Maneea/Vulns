using System.Linq.Expressions;

using Nest;

using Vulns.Core;
using Vulns.Infrastructure;

namespace Vulns.App;

public class VulnerabilityAggregationService
{
    private readonly VulnerabilityRepository _repo;
    private readonly VulnerabilitySearchService _search;

    public VulnerabilityAggregationService(VulnerabilityRepository repo, VulnerabilitySearchService search)
        => (_repo, _search) = (repo, search);

    public async Task<IEnumerable<Dictionary<string, object>>> AggregateAsync(VulnerabilityAggregationCriteria aggregationCriteria, VulnerabilitySearchCriteria searchCriteria, CancellationToken token = default)
    {
        var searchQuery = new SearchDescriptor<VulnerabilityDocument>();
        if (searchCriteria != null)
            searchQuery = _search.ConstructSearchQuery(searchCriteria);
        var aggQuery = AggregationGenerator(aggregationCriteria);
        if (aggQuery == null)
            throw new ArgumentException("No or bad aggregation criteria were provided (criteria is null)");
        return await _repo.AggregateAsync(searchQuery, aggQuery, token);
    }

    private AggregationDictionary? AggregationGenerator(VulnerabilityAggregationCriteria? c, string keyPrefix = "")
    {
        if (c == null || c.Field == VulnerabilityAggregationField.None) return null;
        var key = GenerateAggregationKey(keyPrefix, c);
        var subaggregation = AggregationGenerator(c.SubAggregation, key);
        Expression<Func<VulnerabilityDocument, object?>> field;
        switch (c.Field)
        {
            case VulnerabilityAggregationField.Vulnerabilities:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Cardinality});
                field = v => v.Id; break;
            case VulnerabilityAggregationField.PublishDateRange:
                AssertAggregationType(c, new AggregationType[]{AggregationType.DateHistogram});
                field = v => v.CreatedAt; break;
            case VulnerabilityAggregationField.ModificationDateRange:
                AssertAggregationType(c, new AggregationType[]{AggregationType.DateHistogram});
                field = v => v.ModifiedAt; break;
            case VulnerabilityAggregationField.SeverityRange:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Range});
                field = v => v.Severity!.BaseScore; break;
            case VulnerabilityAggregationField.IssuerId:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.Issuer!.Id; break;
            case VulnerabilityAggregationField.IssuerName:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.Issuer!.ShortName; break;
            case VulnerabilityAggregationField.IssuerCountry:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.Issuer!.Country; break;
            case VulnerabilityAggregationField.SeverityLevel:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.Severity!.Level; break;
            case VulnerabilityAggregationField.ProductName:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.VulnerableProductsNames; break;
            case VulnerabilityAggregationField.VendorName:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.VulnerableVendorNames; break;
            case VulnerabilityAggregationField.IsUserInteractionRequired:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.Severity!.UserInteractionRequired; break;
            case VulnerabilityAggregationField.IsFixAvailable:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.HasFix; break;
            case VulnerabilityAggregationField.IsExploitAvailable:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.HasExploit; break;
            case VulnerabilityAggregationField.ConfidentialityImpact:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.ConfidentialityImpact; break;
            case VulnerabilityAggregationField.IntegrityImpact:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.IntegrityImpact; break;
            case VulnerabilityAggregationField.AvailabilityImpact:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.AvailabilityImpact; break;
            case VulnerabilityAggregationField.AttackVector:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.AttackVector; break;
            case VulnerabilityAggregationField.AttackComplexity:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.AttackComplexity; break;
            case VulnerabilityAggregationField.Weakness:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.Weaknesses; break;
            case VulnerabilityAggregationField.WeaknessAffectedResource:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.WeaknessesAffectedResources; break;
            case VulnerabilityAggregationField.WeaknessPlatform:
                AssertAggregationType(c, new AggregationType[]{AggregationType.Terms, AggregationType.Cardinality});
                field = v => v.WeaknessesPlatforms; break;
            default: return null;
        }
        return AggregationTypeGenerator(key, c.Type, field, c.TypeValue, subaggregation);
    }

    private AggregationDictionary? AggregationTypeGenerator(
        string key,
        AggregationType type,
        Expression<Func<VulnerabilityDocument, object?>> field,
        string? value = null,
        AggregationDictionary? subaggregation = null)
    {
        switch (type)
        {
            case AggregationType.Terms:
                if (int.TryParse(value, out var size) && size.IsBetween(1, 100))
                    return _repo.CreateTermsAggregation(key, field, size, subaggregation: subaggregation);
                return _repo.CreateTermsAggregation(key, field, 10, subaggregation: subaggregation);
            case AggregationType.DateHistogram:
                return _repo.CreateDateHistogramAggregation(key, field, value ?? string.Empty);
            case AggregationType.Range:
                return _repo.CreateRangeAggregation(key, field, subaggregation);
            case AggregationType.Cardinality:
                return _repo.CreateCardinalityAggregation(key, field);
            default: throw new ArgumentException($"Unknown aggregation type {type}");
        }
    }

    private string GenerateAggregationKey(string? prefix, VulnerabilityAggregationCriteria c)
        => string.IsNullOrEmpty(prefix) ? c.ToString() : $"{prefix}-{c.ToString()}";

    private void AssertAggregationType(VulnerabilityAggregationCriteria c, IEnumerable<AggregationType> allowedTypes)
    {
        string testedField = c.Field.ToString();
        var plural = allowedTypes.Count() > 1;
        if (allowedTypes.Contains(c.Type)) return;
        var joinedAllowedTypes = string.Join(", ", allowedTypes.Select(_ => _.ToString()));
        string message = $"The only valid aggregation type{(plural ? "s" : "")} for {testedField} {(plural ? "are" : "is")} {joinedAllowedTypes}";
        throw new ArgumentException(message);

    }
}