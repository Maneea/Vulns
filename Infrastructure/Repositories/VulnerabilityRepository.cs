using System.Linq.Expressions;

using AutoMapper;

using Microsoft.EntityFrameworkCore;

using Nest;

using Vulns.Core;

namespace Vulns.Infrastructure;
public class VulnerabilityRepository : SearchableRepository<Vulnerability, VulnerabilityDocument>
{
    public VulnerabilityRepository(AppDbContext context, IMapper mapper, IElasticClient elastic) : base(elastic, context, mapper) { }

    public async override Task<Vulnerability?> GetAsync(string cveId, CancellationToken token)
        => await context.Vulnerability
            .AsNoTracking()
            .Include(v => v.Issuer)
            .Include(v => v.References)
            .Include(v => v.Weaknesses).ThenInclude(w => w.Parent)
            .Include(v => v.Weaknesses).ThenInclude(w => w.Children)
            .Include(v => v.Weaknesses).ThenInclude(w => w.Consequences)
            .Include(v => v.Weaknesses).ThenInclude(w => w.DetectionMethods)
            .Include(v => v.VulnerableProducts)
            .Where(_ => _.Id == cveId)
            .FirstOrDefaultAsync(token);

    public override async Task<SearchResult<Vulnerability>> TypeaheadAsync(string? phrase, int size, CancellationToken token)
    {
        var matches = await elastic.SearchAsync<VulnerabilityDocument>(s => s
            .Size(size)
            .Query(q => q.Bool(b => b
                .Should(
                    s => s.MatchBoolPrefix(mbp => mbp.Field(f => f.Description).Query(phrase)),
                    s => s.MatchBoolPrefix(mbp => mbp.Field(f => f.Id).Query(phrase == null ? null : phrase.ToUpper())),
                    s => s.MatchBoolPrefix(mbp => mbp.Field(f => f.Id).Boost(1.5).Query(phrase)),
                    s => s.Term(w => w.Id, phrase == null ? null : phrase.ToUpper(), 10)
                )
                .MinimumShouldMatch(1)))
        , token);
        var entities = mapper.Map<IEnumerable<Vulnerability>>(matches.Documents);
        return new(entities, matches.Total);
    }

    public SearchDescriptor<VulnerabilityDocument> ConvertToSearchQuery(string? phrase = null, List<QueryContainer>? filters = null, int from = 0, int size = 10)
    {
        var boolQuery = new BoolQueryDescriptor<VulnerabilityDocument>();
        if (filters != null && filters.Any())
            boolQuery = boolQuery.Filter(filters.ToArray());

        if (!string.IsNullOrEmpty(phrase))
            boolQuery = boolQuery.Must(_ => _.Match(_ => _.Field(v => v.Description).Fuzziness(Fuzziness.Auto).Query(phrase).PrefixLength(4).Operator(Operator.And)));

        return new SearchDescriptor<VulnerabilityDocument>()
            .From(from)
            .Size(size)
            .Query(q => q.Bool(_ => boolQuery));
    }

    public async Task<IEnumerable<Dictionary<string, object>>> AggregateAsync(SearchDescriptor<VulnerabilityDocument> searchQuery, AggregationDictionary aggQuery, CancellationToken token = default)
    {
        var res = await elastic.SearchAsync<VulnerabilityDocument>(searchQuery.Aggregations(aggQuery), token);
        if (res.Aggregations.Any())
            return TransformToDictionaryList(res.Aggregations.First().Key, res.Aggregations.First().Value);
        return new Dictionary<string, object>[] { };
    }

    private List<Dictionary<string, object>> TransformToDictionaryList(string key, IAggregate agg, Dictionary<string, object>? prefill = null)
    {
        var result = new List<Dictionary<string, object>>();
        if (agg as BucketAggregate != null)
        {
            var bucketAgg = (agg as BucketAggregate)!;
            foreach (var bucket in bucketAgg.Items)
                if (bucket as KeyedBucket<object> != null)
                    result = result.Concat(TransformKeyedBucket(key, (bucket as KeyedBucket<object>)!, prefill)).ToList();

                else if (bucket as DateHistogramBucket != null)
                    result = result.Concat(TransformDateHistogramBucket(key, (bucket as DateHistogramBucket)!, prefill)).ToList();

                else if (bucket as RangeBucket != null)
                    result = result.Concat(TransformRangeBucket(key, (bucket as RangeBucket)!, prefill)).ToList();
        }
        else if (agg as ValueAggregate != null)
        {
            var valueAgg = (agg as ValueAggregate)!;
            var dic = prefill ?? new Dictionary<string, object>();
            dic.Add($"{key}-Cardinality", valueAgg.Value ?? 0);
            return new(){dic};
        }
        return result;
    }

    private List<Dictionary<string, object>> TransformKeyedBucket(string key, KeyedBucket<object> keyedBucket, Dictionary<string, object>? prefill = null)
    {
        var dictionary = new Dictionary<string, object>();
        if (prefill != null)
            foreach (var item in prefill)
                dictionary.Add(item.Key, item.Value);

        var term = keyedBucket.KeyAsString ?? keyedBucket.Key.ToString()!;
        dictionary.Add(key, term);
        dictionary.Add($"{key}-Count", keyedBucket.DocCount ?? 0);

        if (keyedBucket.Values.Count() == 0)
            return new List<Dictionary<string, object>>() { dictionary };

        var dictionaryList = new List<Dictionary<string, object>>();
        foreach (var keyValuePair in keyedBucket)
            dictionaryList = dictionaryList.Concat(TransformToDictionaryList(keyValuePair.Key, keyValuePair.Value, dictionary)).ToList();
        return dictionaryList;
    }

    private List<Dictionary<string, object>> TransformDateHistogramBucket(string key, DateHistogramBucket dateHistogramBucket, Dictionary<string, object>? prefill = null)
    {
        var dictionary = new Dictionary<string, object>();
        if (prefill != null)
            foreach (var item in prefill)
                dictionary.Add(item.Key, item.Value);

        dictionary.Add(key, dateHistogramBucket.Date.ToString());
        dictionary.Add($"{key}-Count", dateHistogramBucket.DocCount ?? 0);
        return new List<Dictionary<string, object>>() { dictionary };
    }

    private List<Dictionary<string, object>> TransformRangeBucket(string key, RangeBucket rangeBucket, Dictionary<string, object>? prefill = null)
    {
        var dictionary = new Dictionary<string, object>();
        if (prefill != null)
            foreach (var item in prefill)
                dictionary.Add(item.Key, item.Value);

        dictionary.Add(key, rangeBucket.Key);
        dictionary.Add($"{key}-Count", rangeBucket.DocCount);
        return new List<Dictionary<string, object>>() { dictionary };
    }
}